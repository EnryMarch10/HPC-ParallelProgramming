# Dot product

## Environment setup

Examine the output of `cat /proc/cpuinfo` or `lscpu` to see which SIMD extensions are supported by your CPU.
Look at the _flags_ field for abbreviations like `mmx`,` sse`, `sse2`,` sse3`, `sse4_1`,` sse4_2`, `avx`,` avx2`.

To look at the assembly code generated by the compiler, you can use the following compilation command:

```shell
gcc -std=c99 -Wall -Wpedantic -O2 -march=native -g -S -fverbose-asm simd-dot.c -o simd-dot.s
```

where:

- `-march=native` enables all statements supported by the machine on which you are compiling.
- `-g` generates debugging information; this is useful for showing the source code along with the corresponding assembly code.
- `-S` write the assembly code to the output file.
- `-fverbose-asm` make the output more verbose by adding comments that help associating assembly output with input source lines.

> **NOTE**: sometimes you might want to remove the `-O2` flag; optimization may reorder instructions in such a way that there is
> no longer a direct mapping between source lines and assembly output.

Use the following command to see which compiler flags are enabled by `-march=native`:

```shell
gcc -march=native -Q --help=target
```

## Scalar product

[simd-dot.c](base/simd-dot.c) contains a function that computes the scalar product of two arrays.
The program prints the mean execution times of the serial and SIMD versions; the goal of this exercise is to develop the SIMD
version.
The dot product requires little time even with large arrays; therefore, you might not observe a significant speedup.

**1. Auto-vectorization.** Check the effectiveness of compiler auto-vectorization of `scalar_dot()`. Compile as follows:

```shell
gcc -O2 -march=native -ftree-vectorize -fopt-info-vec-all \
    simd-dot.c -o simd-dot -lm 2>&1 | grep "loop vectorized"
```

The `-ftree-vectorize` enables auto-vectorization; `-fopt-info-vec-all` flag prints some "informative" messages (so to speak) on
standard error to show which loops have been vectorized.

Recent versions of GCC can vectorize the `serial_dot()` function.
Older versions vectorize the loop in the `fill()` function, but not that in `serial_dot()`.

**2. Auto-vectorization (second attempt).** Examine the assembly code to verify that SIMD instructions have indeed been emitted:

```shell
gcc -S -c -march=native -O2 -fverbose-asm -ftree-vectorize simd-dot.c -o simd-dot.s
```

If you have an older version of GCC, examine the diagnostic messages of the compiler (remove the strings from `2>&1` onwards from
the previous command); you should see something like:

```shell
simd-dot.c:157:5: note: reduction: unsafe fp math optimization: r_17 = _9 + r_20;
```

that refers to the "for" loop of the `serial_dot()` function. The message reports that the instructions:

```C
r += x[i] * y[i];
```

are part of a reduction operation involving operands of type `float`.
Since floating-point arithmetic is not commutative, the compiler did not vectorize in order not to alter the order of the sums.
To ignore the problem, recompile the program with the `-funsafe-math-optimizations` flag:

```shell
gcc -O2 -march=native -ftree-vectorize -fopt-info-vec-all \
    -funsafe-math-optimizations \
    simd-dot.c -o simd-dot -lm 2>&1 | grep "loop vectorized"
```

The following message should now appear:

```shell
simd-dot.c:165:5: optimized: loop vectorized using 32 byte vectors
```

**3. Vectorize the code manually.** Implement `simd_dot()` using the vector data types of the GCC compiler.
The function look similar to the one computing the sum-reduction (refer to `simd-vsum-vector.c` in the examples archive).
The function `simd_dot()` should work correctly for any length $n$ of the input arrays, which might not be a multiple of the SIMD
array length.
Input arrays are always correctly aligned.

Compile with:

```shell
gcc -std=c99 -Wall -Wpedantic -O2 -march=native simd-dot.c -o simd-dot -lm
```

(do _not_ use `-ftree-vectorize`, since we want to compare the execution time of the pure scalar version with the hand-tuned SIMD
implementation).

Run with:

```shell
./simd-dot [n]
```

Example:

```shell
./simd-dot 20000000
```

## Files

- [simd-dot.c](base/simd-dot.c)
- [hpc.h](../../include/hpc.h)
